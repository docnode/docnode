---
title: Operations and Diff
---

import { diff } from "@/components/diff";

A transaction has associated with it a set of `operations`, `inverseOperations` and a `diff`.

The `changeEvent` contains those 3 properties while the `normalizeEvent` contains only the `diff`:

```ts
doc.onNormalize(({ diff }) => {
  console.log("normalize", diff);
});

doc.onChange(({ operations, inverseOperations, diff }) => {
  console.log("change", operations, inverseOperations, diff);
});
```

You can expand the rows in the following table to see a description of these objects:

<CollapsibleTable
  rows={{
    operations: {
      name: "operations",
      type: "Operations",
      description: `The operations applied to the document in this transaction. Can be applied to this or another document with \`doc.applyOperations(operations)\`.

Unless you're building your own sync solution or undo manager, you don't need to use it. Even if that's the case, its internal structure should be irrelevant since \`applyOperations\` is the only API that understands it. But for the curious, its simplified form is:

\`\`\`ts
type OrderedOperation =
| InsertOperation
| DeleteOperation
| MoveOperation;

type Operations = [OrderedOperation[], StatePatch];

\`\`\`
`,
      required: true,
    },
    inverseOperations: {
      name: "inverseOperations",
      type: "Operations",
      description: "When applied to a document, it will revert the changes made by the operations. Regarding its form and utility, it is the same as operations, see description above.",
      required: true,
    },
    // prettier-ignore
    diff: {
      name: "diff",
      type: "Diff",
      description: `
It points to the nodes that were modified. Of the four sets, the only pair that is not mutually exclusive is \`moved\` and \`updated\`.

${diff}

In the \`normalize\` and \`change\` events, a top-to-bottom dirty check can be performed to normalize or re-render, and that is usually fast enough. But using the diff with fine-grained updates is the most performant approach.
`,
required: true,
},
}}
/>

These three objects are cleared or reset at the end of the [change stage](/docs/doc-lifecycle). Until then, [`getPrev`](/docs/nodes#node-state) will return the value of the state that the node had at the beginning of the transaction.

## Operations

An alternative way to describe a document or the change of a document to a later state is as a set of operations.

In OT mode, the set of operations must be ordered. For all clients to converge on the same document, they must apply the same operations in the same order. Therefore, a central server is required as the source of truth.

In CRDT mode, the operations will be commutative. This means that operations can be applied in any order or multiple times, and the resulting document will be the same. At the cost of higher metadata, CRDTs are suitable for P2P.
