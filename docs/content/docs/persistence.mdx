---
title: Persistence
description: Strategies to persist and sync a Doc
---

import { Accordion, Accordions } from "fumadocs-ui/components/accordion";

This page covers practical ways to persist a Doc on a server. DocNode uses an OT-style model: all clients must apply operations in the same order to converge, or the server can send back a full document snapshot.

## Strategy 1: Send the full document

The simplest approach is to send the whole document to the server on every change.

```ts
doc.onChange(() => {
  // JSON is the easiest format because it's supported out of the box, but
  // you are free to implement your own serializer (e.g. HTML)
  const jsonDoc = doc.toJSON();
  // Choose the method you want to send the document to your server
  fetch("/save", { method: "POST", body: jsonDoc });
});
```

Pros

- Very easy to implement
- Useful baseline before adding incremental updates

Cons

- Sends the entire document every time. The cost of data over the wire can be significant, especially if the document is large.
- If two clients edit the same document at the same time, the server will have to discard the operations of one of them.

<Callout type="info">
  The root node ID is also the document ID. You can read it from the JSON as
  `const docId = jsonDoc[0]`.
</Callout>

## Strategy 2: Send operations (DIY)

Roll your own sync layer. The complexity is entirely up to you. A basic setup posts operations to the server, while an advanced one adds authentication, debouncing, retry policies, multi tab synchronization, version history, local storage, and other niceties.

The only requirement is that all clients must apply the operations in the same order. If a client connects and the server no longer holds the missing operations, the client must pull the current document state first, then start consuming live operations.

<Accordions type="single" collapsible>
  <Accordion title="Barebones example" id="example">
    
<Callout type="warning">
  This example is a work in progress. It may contain outdated or incorrect
  information.
</Callout>

The `change` event includes operations in a compact JSON form. Use a small queue to avoid losing operations while a save is in flight.

Client

```ts
import type { Doc, Operations } from "docnode";

export function saveDocOnChange(doc: Doc) {
  let pending: Operations[] = [];
  let inflight: Promise<void> | null = null;
  const retryDelayMs = 500;

  const flushIfIdle = async (): Promise<void> => {
    if (inflight || pending.length === 0) return;

    const batch = pending;
    pending = [];

    inflight = (async () => {
      try {
        const res = await fetch("/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ docId: doc.id, operations: batch }),
        });
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
        const jsonDoc = await res.json();
        doc.fromJSON(jsonDoc);
      } catch {
        pending = [...batch, ...pending];
        await new Promise((r) => setTimeout(r, retryDelayMs));
      } finally {
        inflight = null;
        void flushIfIdle();
      }
    })();

    await inflight;
  };

  doc.onChange(({ operations }) => {
    pending.push(operations);
    void flushIfIdle();
  });
}

// Usage
// saveDocOnChange(doc);
```

Server

```ts
import { Doc, type Operations } from "docnode";

const docConfig: DocConfig = {
  /* your config */
};

app.post("/save", async (req, res) => {
  const { docId, operations } = req.body as {
    docId: string;
    operations: Operations[]; // array of batches
  };

  const stored = await getJsonDoc(docId);
  const doc = Doc.fromJSON(docConfig, stored);
  for (const ops of operations) doc.applyOperations(ops);
  doc.forceCommit();
  const saved = doc.toJSON();
  await saveJsonDoc(docId, saved);
  res.json(saved);
});
```

  </Accordion>
</Accordions>

Pros

- It supports concurrency handling and conflict resolution, allowing real-time or even offline-first collaboration.
- Less data over the wire: you only send the server super-compressed descriptions of what changed (the operations).

Cons

- Complex setup, especially for implementing features like those mentioned above: authentication, debouncing, retry policies, multi tab synchronization, version history, local storage, etc.

---

## Strategy 3: DocNode Sync (recommended)

DocNode Sync provides a batteries‑included, local‑first client/server that synchronizes documents in real time:

- WebSockets for live sync
- IndexedDB for local storage
- Shared Worker for cross‑tab coordination

It can adapt strategy by context:

- Single writer: send debounced operations and squash on the server only when needed (reads).
- Multiple writers: send immediately and broadcast to all connected clients.

Pros

- The same as strategy 2, plus:
- Batteries-included and battle-tested solution.
- You support this project.

Cons

- Just an affordable and reasonable paid license!
