---
title: Persistence
description: Strategies to persist and sync a Doc
---

<Callout type="warning">
  This page is a work in progress. It may contain outdated or incorrect
  information.
</Callout>

This page covers practical ways to persist a Doc on a server. DocNode uses an OT-style model: all clients must apply operations in the same order to converge, or the server can send back a full document snapshot.

## Strategy 1: Send the full document

The simplest approach is to send the whole document to the server on every change.

```ts
doc.onChange(() => {
  // JSON is the easiest format because it's supported out of the box, but
  // you are free to implement your own serializer (e.g. HTML)
  const jsonDoc = doc.toJSON();
  // Choose the method you want to send the document to your server
  fetch("/save", { method: "POST", body: jsonDoc });
});
```

Pros

- Very easy to implement
- Useful baseline before adding incremental updates

Cons

- Sends the entire document every time. The cost of data over the wire can be significant, especially if the document is large.
- No concurrency handling (the server must decide which writer wins)
  {/* - ALT: If two clients edit the same document at the same time, the server will have to discard the operations of one of them. This may not be a problem if, for example, the documents don't require collaboration between users or devices (local-only). */}

<Callout type="info">
  The root node ID is also the document ID. You can read it from the JSON as
  `const docId = jsonDoc[0]`.
</Callout>

## Strategy 2: Send operations with a single‑flight queue

The `change` event includes operations in a compact JSON form. Use a small queue to avoid losing operations while a save is in flight.

Client

```ts
import type { Doc, Operations } from "docnode";

export function saveDocOnChange(doc: Doc) {
  let pending: Operations[] = [];
  let inflight: Promise<void> | null = null;
  const retryDelayMs = 500;

  const flushIfIdle = async (): Promise<void> => {
    if (inflight || pending.length === 0) return;

    const batch = pending;
    pending = [];

    inflight = (async () => {
      try {
        const res = await fetch("/save", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ docId: doc.id, operations: batch }),
        });
        if (!res.ok) throw new Error(`Save failed: ${res.status}`);
        const jsonDoc = await res.json();
        doc.fromJSON(jsonDoc);
      } catch {
        pending = [...batch, ...pending];
        await new Promise((r) => setTimeout(r, retryDelayMs));
      } finally {
        inflight = null;
        void flushIfIdle();
      }
    })();

    await inflight;
  };

  doc.onChange(({ operations }) => {
    pending.push(operations);
    void flushIfIdle();
  });
}

// Usage
// saveDocOnChange(doc);
```

Server

```ts
import { Doc, type Operations } from "docnode";

const docConfig: DocConfig = {
  /* your config */
};

app.post("/save", async (req, res) => {
  const { docId, operations } = req.body as {
    docId: string;
    operations: Operations[]; // array of batches
  };

  const stored = await getJsonDoc(docId);
  const doc = Doc.fromJSON(docConfig, stored);
  for (const ops of operations) doc.applyOperations(ops);

  const saved = doc.toJSON();
  await saveJsonDoc(docId, saved);
  res.json(saved);
});
```

Pros

- Efficient over the wire, especially for large documents
- Robust to in‑flight saves: no dropped operations

Cons

- The server returns the entire document on each request (this can be resolved)

---

## DocNode Sync (recommended)

DocNode Sync provides a batteries‑included, local‑first client/server that synchronizes documents in real time:

- WebSockets for live sync
- IndexedDB for local storage
- Shared Worker for cross‑tab coordination

It can adapt strategy by context:

- Single writer: buffer and squash on the server
- Multiple writers: apply eagerly and propagate without conflicts
